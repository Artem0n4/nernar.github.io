# Обработка существ

Существо представляет из себя мягкое физическое тело, которое "живет" и перемещается по миру. Помимо физической части, существа (или же мобы, энтити) облададают визуальной, она не определяет физическую форму, а лишь позволяет отображать существо в игре. Нередко с существом можно взаимодействовать, к примеру для получения ресурсов или обмена одних на другие. Познакомимся же с возможностями их обработки.

## Разница подходов

Когда мы говорим о существе, важно понимать кто на самом деле отвечает за его перемещения, форму и прочие свойства. До этого неоднократно была затронута тема клиента и сервера, подходы не изменятся и останутся на протяжении всей документации и этапов вашего моддинга. Следуя этим принципам — сервер отвечает за обработку расположения существа в мире и его физическую форму, а клиент лишь отрисовывает модель вашего существа.

Создавайте проекты на основе механик существ, ведь их так мало! Движок предоставляет методы как для обработки визуальной части существ, так и тонкой настройки их поведения. Естественно, серверные функции нельзя использовать на стороне клиента, а клиентские на сервере не будут иметь никакого смысла. Не волнуйтесь, в статье описано какой из методов и где должен использоваться.

## Местоположение и поворот

<div className="resource-atlas-align-box">

![moving-and-rotation.gif](/images/entities/moving-and-rotation.gif)

</div>

Ключевым определением существа в мире являются его координаты, а также визуальное направление взгляда. Интеллект позволяет управлять этими свойствами, а разработчик может как угодно менять их в любой момент существования измерения.

Начнем с изменения местоположения, для этого используется функция с соответствующим названием:

```js
Entity.setPosition(entityUid, x, y, z);
```

Если с координатами все понятно (а если нет, рассмотрите [систему координат](../environment/modifying-region.md#система-координат)), то что же такое этот ваш уникальный идентификатор? Фактически, это ячейка в памяти нативного объекта, ну а если говорить более простыми словами, идентификационный номер вашего существа. Он существует лишь пока загружено измерение, а также чанк, в котором находится существо.

Для получения идентификаторов окружающих вас мобов есть несколько способов, одним из которых является [получение списка существ между двух точек](../environment/modifying-region.md#существа). Но а что, если к примеру, нам нужно заниматься обработкой каждого появившегося в поле зрения клиентов существа? Для этого есть несколько полезных событий, вроде *EntityAdded* и *EntityDeath*:

```js
Callback.addCallback("EntityAdded", function(entityUid) {
    if (Entity.getDimension(entityUid) == EDimension.NORMAL) {
        const position = Entity.getPosition(entityUid);
        const surface = GenerationUtils.findSurface(position.x, 32, position.z);
        if (surface.y > 0) {
            Entity.setPosition(entityUid, surface.x, surface.y + 2, surface.z);
        }
    }
});
```

В этом случае существо, появившееся в любой точке обычного мира (в том числе и игрок), переместится в пещеру под собой (либо, если ее нет, останется на той же точке) на высоте до 32 блоков. Воспользуйтесь этим же калбеком для изменения любых других свойств существ, даже вроде добавления эффектов. Что же касается изменения координат, я нередко замечал этот метод в событиях перемещения существ между мирами.

Идем дальше. Поворот существа отображает направление его движения, что не столь актуально для существ с интеллектом (ибо интеллект сразу повернет ее обратно), но зато весьма эффективно для бросаемых предметов и стрел:

```js
Entity.setLookAngle(entityUid, yaw, pitch);
```

Поворот относительно оси рысканья (или же yaw, сравнимо с осью x) и оси крена (или же pitch, сравнимо с осью y) задаются в радианах, где `Math.PI` означает поворот на 180 градусов, `Math.PI * 2` — полный поворот вокруг своей оси (на 360, конечно же) и так далее. Угол поворота не имеет ограничений и может принимать любые значения, не ограничиваясь лишь полным поворотом вокруг своей оси.

Почему бы не перейти к чему-то более интересному, скажем, реализации раздатчика? Для этого, можно разместить стрелу, направленную в сторону нажатия по блоку (зачем нужен предопределенный поворот, если игрок сам может его определить):

```js
Callback.addCallback("ItemUse", function(coords, item, block, isRemote, playerUid) {
    const region = BlockSource.getDefaultForActor(playerUid);
    if (region) {
        const entityUid = region.spawnEntity(coords.x, coords.y, coords.z, EEntityType.ARROW);
        const rotation = Entity.getLookAt(entityUid, coords.relative.x, coords.relative.y, coords.relative.z);
        Entity.setLookAngle(entityUid, rotation.yaw, rotation.pitch);
    }
});
```

Используя относительные координаты (соседний блок к той стороне, на которую мы нажали) получим углы поворота, на который должна быть повернута стрела для достижения цели. Стрела по умолчанию не имеет ускорения, так что она просто "вылетит" из нажатого блока. Рассмотрите [World.getRelativeCoords](/api/World/getRelativeCoords) для получения относительных координат любого блока.

Помимо простого установки угла обзора, движок предоставляет функционал для наиболее часто используемых формул. К ним относятся и методы, упрощающие предыдущую реализацию вылета стрелы:

```js
Callback.addCallback("ItemUse", function(coords, item, block, isRemote, playerUid) {
    const region = BlockSource.getDefaultForActor(playerUid);
    if (region) {
        const entityUid = region.spawnEntity(coords.x, coords.y, coords.z, EEntityType.ARROW);
        Entity.lookAtCoords(entityUid, coords.relative);
    }
})
```

Что эквивалентно прошлой реализации, просто итоговый код становится короче. Ну даже не знаю, можем переместить существо в точку, на которую направлен его взгляд:

```js
Callback.addCallback("EntityHurt", function(attackerUid, entityUid, damageValue, damageType) {
    if (Entity.getType(attackerUid) == EEntityType.PLAYER) {
        const rotation = Entity.getLookAngle(entityUid);
        const vector = Entity.getLookVectorByAngle(rotation);
        Entity.addPosition(entityUid, vector.x, vector.y, vector.z);
});
```

Вектор здесь представляет собой отклонения по каждой из координат, перемещая существо буквально на блок дальше в сторону его взгляда (так, монстры будут становиться ближе к игроку, а пассивные мобы наоборот отдаляться). Поэкспериментируйте с этой реализацией, метод добавления координат суммирует прошлые координаты с вектором.

Поворот головы (ведь поворот остального тела осуществляется с небольшим отставанием от головы) определяется даже в случае, если существо не имеет таковой части тела. В этом можно убедиться с помощью пакетов ресурсов, либо включив отладку перемещений интеллекта в скрытых настройках игры.

## Ускорение

<div className="resource-atlas-align-box">

![velocity.gif](/images/entities/velocity.gif)

</div>

Основной частью любого физического мира (конечно же, у нас в игре есть физика) является именно ускорение; используя его, мобы двигаются с заданным вектором в любую сторону света. На этом основаны любые движения существ, начиная от перемещения игрока, стрел, и заканчивая интеллектом.

```js
Entity.setVelocity(entityUid, x, y, z);
```

Используя и работая с векторами, этот метод поможет добиться интересных результатов. А большего и не нужно; чуть физики и математики, либо использование уже готовых формул и кода! Каждому выбирать свой путь, а начать можно с нескольких простых примеров. Скажем, почему бы не ускорить выбрасываемые предметы по высоте?

```js
Callback.addCallback("EntityAdded", function(entityUid) {
    if (Entity.getType(entityUid) == EEntityType.ITEM) {
        const velocity = Entity.getVelocity(entityUid);
        Entity.setVelocity(entityUid, velocity.x, velocity.y + Math.random() * 0.4 - 0.2, velocity.z);
    }
});
```

<!-- TODO: Какова постоянная свободного падения в игре? -->

Чуть ускорившись, дроп (выброшенные предметы) через небольшой промежуток времени направится вниз. Давайте сократим этот же код до пары строчек, также как делали до этого с положением:

```js
Callback.addCallback("EntityAdded", function(entityUid) {
    if (Entity.getType(entityUid) == EEntityType.ITEM) {
        Entity.addVelocity(entityUid, 0, Math.random() * 0.4 - 0.2, 0);
    }
});
```

Во времена ModPE у нас существовала традиция документировать создание стрел, схожий по своей сути код пропагандировался многими учебниками и группами. Сделаем тоже самое — пусть стрела полетит в направлении взгляда игрока:

```js
const VANILLA_ARROW_SPEED = 0.25;

Callback.addCallback("ItemUseNoTarget", function(item, playerUid) {
    if (item.id == VanillaItemID.arrow) {
        const vector = Entity.getLookVector(playerUid);
        const position = Entity.getPosition(playerUid);
        const entityUid = region.spawnEntity(
            position.x + vector.x * 0.12,
            position.y + vector.y * 0.12,
            position.z + vector.z * 0.12,
            EEntityType.ARROW
        );
        Entity.setVelocity(
            entityUid,
            vector.x * VANILLA_ARROW_SPEED,
            vector.y * VANILLA_ARROW_SPEED + 0.05,
            vector.z * VANILLA_ARROW_SPEED
        );
    }
});
```

Призывая стрелу рядом с хитбоксом игрока (если призвать стрелу в самом игроке, очевидно что она просто попадет в него), мы ускоряем стрелу на небольшую силу и вверх. Может быть запускать стрелы рукой игрока и не практично (летят медленно и не далеко), но принцип вы поняли. Увеличьте ускорение, поменяв его высоту и изменив скорость — и ручные стрелы не будут отличаться от лука.

<!-- TODO: Здесь могла быть ваша реклама, но ShootLib не оптимизирован под мультиплеер. -->

Существуют и объекты без физики. Вы хоть раз замечали изменение ускорения у огненного шара, выпускаемого гастом? А ведь это тоже существо, но оно двигается линейно и без сопротивления:

```js
Callback.addCallback("ItemUseNoTarget", function(item, playerUid) {
    if (item.id == VanillaItemID.fireball) {
        const position = Entity.getPosition(playerUid);
        Entity.moveToAngle(
            region.spawnEntity(
                position.x, position.y, position.z,
                EEntityType.FIREBALL
            ),
            Entity.getLookAngle(playerUid),
            { speed: 0.09 }
        );
    }
});
```

Теперь огненные шары могут быть запущены не только раздатчиком или гастом, но и нами. Использование метода [Entity.moveToAngle](/api/Entity/moveToAngle) позволяет упростить код с запуском стрелы выше, задействуя ускорение еще быстрее.

Дополнительные примеры использования механики ускорения можно найти в моде Portal Gun, это отличный способ путешествовать по миру. В нем нет сложных формул, что на самом деле лишь помогает еще лучше понять как все работает.

## Обработчик игрока

Игрок, в отличии от большинства других существ, имеет собственные уникальные характеристики, которые другие существа попросту не должны иметь. Специально для их изменения и получения созданы обработчики, речь о которых пойдет в этом параграфе.

## Прочие свойства

Все описанные ранее методы вызываются на стороне сервера, это довольно важно, поскольку клиентские события и сам клиент не могут обработать существ, изменяя их свойства еще и для всех игроков.
