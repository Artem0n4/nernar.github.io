# Сохраняем данные

Обычно определенные данные относят к миру, в то время как другие же, должны быть уникальными для каждого игрока. От этого и зависит, какие сохранения и кем должны быть обработаны. Способы сохранения разные, виды данных тоже, так что рассмотрим основные из них.

## Конфиг

Пожалуй наиболее простым способом обработки данных остается конфиг, или же [\_\_config\_\_](/api/__config__). Он сохраняет сугубо клиентские настройки и может быть изменен через интерфейс браузера модов. Ранее, в статье [Конфигурация свойств](../basics/mod-structure.md#конфигурация-свойств) были рассмотрены форматы файлов *config.json* и *config.info.json*, теперь же будет рассмотрено считывание и изменение этих данных.

```js
__config__.getBool("extensions.cropGrowth");
__config__.getDouble("position.classic.x");
__config__.getFloat("position.classic.y");
__config__.getInteger("checkTime");
__config__.getString("style");
```

Эти базовые методы позволяют получить конкретный тип данных: булевые значения, числа с фиксированной или плавающей точкой, целочисленные и строковые значения соответственно. Если значение в конфиге отсутствует или не соответствует запрашиваему типу, будут возвращены `false`, `0.0`, `0.0`, `0` и `null` в том же порядке.

Создайте отдельный файл или класс и загружайте эти данные единожды, обычно они обновляются лишь на этапе загрузке мода. Не знаете какой тип данных должен быть получен из конфига или просто хотите проверить, есть ли нужное значение? Запросите значение с помощью универсального метода:

```js
__config__.get("style");
```

Вне зависимости от полученного значения, оно будет возвращено в нужном типе. Если же значения нет, будет возвращено `null` как в случае с отсутствием строкового.

Но ведь мы же хотим не только считывать, но и изменять данные:

```js
const DESPAWN_RANGE = Math.min(Math.max(
    __config__.getInteger("despawn_range"), 192
), 48);
__config__.set("despawn_range", DESPAWN_RANGE);
__config__.save();
```

В этом случае мы считываем целочисленное значение `despawn_range` и проверяем, чтобы оно было в диапазоне от 48 до 192. И здесь же, сохраняем значение на случай если оно было изменено. Рассмотрите [config.info.json](../basics/mod-structure.md#configinfojson) для ограничения этих значений еще и в интерфейсе.

Цепочек установки значений перед сохранением может быть сколько угодно:

```js
__config__.set("despawn_range", 64);
__config__.set("style", "transparent");
__config__.set("extensions.energy", true);
__config__.save();
```

Установка значения с другим типом данных (отличном от существующего в конфиге) не является проблемой. И на случай если проекту в любом случае необходимо значение, и просто для восстановления данных, существует:

```js
__config__.checkAndRestore({
    despawn_range: 64,
    style: "transparent",
    extensions: {
        energy: true
    }
});
```

Это хорошая практика добавить подобную реализацию в код — отсутствующие значения будут добавлены в конфиг, а несоответствующие типы данных будут заменены. Сохранение будет проведено автоматически.

:::info Для каждого клиента — свой конфиг

Настройки сервера должны быть получены пакетом (если это необходимо), но иногда большую часть конфига составляют клиентские настройки, вроде предпочтений размеров интерфейса и прочего.

:::

### Дополнительные конфиги

В большинстве случаев, стандартного конфига будет вполне достаточно. Но возможно, вам необходимо разделить существующие данные, создать прототип со стандартными значениями или добавить уникальные вариации. На этот случай приходит конструктор класса [Config](/api/Config), такой конфиг ничем не будет отличаться от стандартного:

```js
const PROTO_CONFIG = new Config(__dir__ + "config.proto.json");
const GLOBAL_CONFIG = new Config(new java.io.File(__dir__, "config.json"));
```

К примеру, мы можем восстановить конфиг на основе заранее созданного прототипа:

```js
__config__.checkAndRestore(FileTools.ReadText(
    PROTO_CONFIG.getPath()
));
```

Конфигов может быть сколько угодно, сохраняйте изменения с помощью `config.save()` и обновляйте их, используя `config.reload()`.

## Сохранения

Сохранения используются для хранения большого количества данных или любых других в виде объектов. Хотя само сохранение данных может быть зарегистрировано где угодно, использованы они будут лишь на стороне сервера. Хранение данных происходит с помощью [Saver](/api/Saver) и его нескольких методов.

```js
Saver.addSavesScope("некийМод.некийКонтекст", function(data) {
    // действия с полученными вследствие загрузки данными
}, function() {
    return {
        // некие данные для сохранения
    };
});
```

Отдельные потоки данных прекрасно сохраняются здесь. Первая функция выполняется во время загрузки мира для получения прочитанных данных, а вторая выполняется неоднократно во время самой игры для их сохранения. Возвращаемый объект для сохранения может содержать неограниченное количество вложенных примитов и массивов, главное, чтобы они находились внутри объекта. По этой причине, эта функция и сохраняет "контекст".

Вернемся к небольшому примеру жидкостного хранилища, созданного в статье [Маппинг и обновления](../blocks/renders/block-renderer.md#маппинг-и-обновления). У нас уже есть готовый объект `placedTanksByDimension`, содержащий все необходимые данные для сохранения. В таком случае, готовый вариант сохранения будет выглядеть так:

```js
Saver.addSavesScope("abstractModName.tanks", function(data) {
    placedTanksByDimension = data;
}, function() {
    return placedTanksByDimension;
});
```

Опять же, мы можем проверять получаемые данные, конструирировать возвращаемый объект и разворачиваться в любую сторону каждой функции обработчика. Добавим больше различных типов данных:

```js
let despawnRange = 64;
let style = "transparent";
let energyExtension = true;

Saver.addSavesScope("abstractModName", function(data) {
    despawnRange = data.despawn_range || despawnRange;
    style = data.style || style;
    if (data.extensions) {
        energyExtension = data.extensions.energy;
    }
}, function() {
    return {
        despawn_range: despawnRange,
        style: style,
        extensions: {
            energy: energyExtension
        }
    };
});
```

Желательно проверять существуют ли необходимые данные перед их использованием.

### Экземпляры и классы

Когда количество объектов превышает нескольких штук, просто хранить данные в отдельно выделенном массиве становится несколько хаотичным. Куда лучше сохранять отдельные экземляры ваших классов.

Любой обработчик состоит из уже рассмотренных функции чтения, сохранения и идентификатора самого обработчика. Последний задействуется как раз для регистрации новых экземляров и их игнорирования. Предположим, существует некий класс `LevitatingAspectItem`, содержащий информацию о текущем местоположении левитирующего предмета и привязанного к нему алтаря:

```ts
class AspectableAltar extends Altar {
    id: number;
    ...
}

class LevitatingAspectItem {
    altarId: number;
    position: Vector;

    constructor(altar: AspectableAltar) {
        const { id } = altar;
        this.altarId = id;
        this.position = new Vector(0, 0, 0);
        ...
    }

    update() {
        ...
    }
}
```

Мы можем воспользоваться изученным ранее `Saver.addSavesScope`, так может регистрировать его каждый раз? Как только объект перестанет быть актуален, ритуал будет завершен, сохраняемый обработчик останется. Это явно не то, что здесь необходимо, да и есть вариант получше.

На этот случай каждый экземпляр регулируется отдельно:

```ts
class LevitatingAspectItem {
    static saverId = Saver.registerObjectSaver("abstractModName.LevitatingAspectItem", {
        save: function(instance) {
            const { altarId, position } = instance;
            return { altarId, position };
        },
        read: function(data) {
            const altar = Altar.resolveById(data.altarId);
            if (!altar) return null;
            const aspect = new LevitatingAspectItem(altar);
            aspect.position = data.position;
            return aspect;
        }
    });

    ...

    constructor(altar: AspectableAltar) {
        ...
        Saver.registerObject(this, LevitatingAspectItem.saverId);
    }
}
```

Используя идентификатор созданного обработчика, классы будут восстановлены вместе со следующим входом в мир. Не забудьте позаботиться о связке созданных объектов с обработчиком, например, привязкой к алтарю. Но не менее важно "выгружать" объекты из списка сохранения, для этого реализуйте, к примеру, метод `destroy`:

```ts
class LevitatingAspectItem {
    ...
    destroy() {
        ...
        Saver.setObjectIgnored(this, true);
    }
}
```

И позаботьтесь о вызове этого метода, когда ваш класс более не требуется.

### Сериализация

```mdx-code-block
import NotImplemented from "@site/src/components/NotImplemented"

<NotImplemented />
```

## Прочие реализации

Некоторые классы заведомо включают в себя сохранение данных — такие как контейнеры, игровые объекты, тайлы и прочие. Данные не обязательно должны состоять из объектов, прямая обработка файлов в большом количестве случаев не является проблемой, движок предоставляет интерфейсы и для работы с ними. Мы рассмотрим их в следующих статьях.
