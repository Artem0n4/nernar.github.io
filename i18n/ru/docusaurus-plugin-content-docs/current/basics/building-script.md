# Сборка скриптов

Помимо того, что существует возможность напрямую задать исполняемый скрипт, часто существует потребность в разделении исходного кода по файлам. Как только проект начинает содержать первые классы, утильные функции, и прочие вещи, которые следовало бы разделить, работать в одном файле становится просто невозможно. Тут нам на помощь приходят сборочные файлы, а также продвинутые настройки тулчейна.

## Компиляция файлов

Для запуска файлов используется свойство `compile`, добавление какого-либо скрипта в него приведет к его запуску. Мы уже рассматривали описание его элемента:

```json
{
    "path": "относительный путь от папки, в которой расположен build.config",
    "sourceType": "launcher, main, custom, preloader или library"
}
```

Если вы не знаете, какой `sourceType` нужно выбрать, рассмотрите [Жизненный цикл мода](mod-lifecycle.md). Как уже было сказано, свойство `compile` задает скрипты, которые будут скомпилированы и загружены. Например, *build.config* может выглядеть так:

```json title="build.config"
{
    ...
    "compile": [
        {
            "path": "main.js",
            "sourceType": "main"
        }
    ]
}
```

Что означает, что скрипт будет загружен из текущей папки из файла *main.js* и запустится после вызова `Launch();` из лаунчера проекта. Но в этом случае файл не собирается, а просто загружается из уже существующего. А что, если мы хотим именно собирать несколько файлов в один?

## Скриптов может быть сколько угодно

А для того чтобы собрать их все, нужно объединить скрипты в один. Это сделает за вас Inner Core или Type Script Compiler тулчейна в зависимости от того, какую платформу вы используете.

Начнем с того, что для сборки нужно определить свойство `buildDirs` вашего *build.config*:

```json title="build.config"
{
    ...
    "buildDirs": [
        {
            "targetSource": "main.js",
            "dir": "dev/"
        }
    ]
}
```

Теперь файлы, находящиеся в папке *dev/* будут собраны в файл *main.js*, который мы уже определили ранее. Но для того чтобы определить скрипты, которые будут собраны, помимо этого нам нужно определить файл *.includes* в созданной директории *dev/*.

## .includes

Файл описывает список файлов, которые будут включены в итоговый скрипт. Рассмотрим его реализацию на примере:

```gitignore title=".includes"
# комментарии могут описывать почему включен тот или иной файл
header.js

api/tests.js
api/globals.js

# будут включены все файлы в папке, в случае тулчейна
# дополнительно включаются еще и подпапки
module/.

// также комментарии могут быть использованы в таком виде
```

Пустые строки и комментарии при сборке файлов игнорируются. В данном случае в скрипт будет включено минимум три файла: *header.js*, а также *tests.js* и *globals.js* в папке *api/*. Папки *module/* может и не существовать вовсе. Несуществующие файлы игнорируются, отправляя предупреждение об этом в лог.

Эти же правила применяются и к тулчейну, однако комментарии в нем могут содержать свойства для настройки *tsconfig.json*.

### Сила комментариев тулчейна

Сборочные файлы в тулчейне, помимо описания списка файлов, могут содержать описание для опций компилятора, а также исключения уже включенных в сборку файлов:

```gitignore title=".includes"
# removeComments
// checkJs: true

# lib: es6, es2016.array.include

header.js

# очень важные файлы
module/.

!module/tests.ts

# target: es3
```

В сборку будут включены файл *header.js* и все файлы из папки и подпапок *module/*, исключая *module/tests.ts*. Файлы включаются как и исключаются лишь в случае если они существуют. Так как тулчейн собирает *tsconfig.json*, пути могут содержать и glob-выборки для файлов:

```gitignore title=".includes"
module/tile_*.js
```

Таким образом, будут включены файлы *module/tile_chest.js* и *module/tile_advanced_workbench.js*, но не будут включены *module/bounce.js* и *module/tile_bedrock.ts*.

:::info Разбор описания опций компилятора

Комментарии будут исключены из собранного скрипта (и из деклараций тоже), Java Script будет проверен на соответствие типов также как и Type Script, вместо последних библиотек будут включены лишь ES6 (ES2015) и `Array.include` из ES2016, а выходной скрипт будет представлен в ES3 вместо ES5. Если вам не требуется ни одна из этих опций или любая другая, просто не используйте их.

:::

## Сборка с тулчейном

Помимо описания сборочного файла, структура выше не относится к тулчейну. Тулчейн автоматически определяет передаваемые значения, определяя что необходимо собрать, файл или папку. Помимо этого, он поддерживает сборку с помощью Type Script. Для сборки или компиляции нужного файла, используйте:

```json title="make.json"
{
    ...
    "sources": [
        {
            "type": "main",
            "source": "dev",
            "language": "typescript",
            "target": "main.js"
        }
    ]
}
```

Это сделает тоже самое, что и свойства `compile` и `buildDirs`, описанные ранее; но также, будут собраны и файлы, которые имеют расширение *.ts*. Изучите свойства *make.json* для получения подробностей.
